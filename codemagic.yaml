workflows:
  guardian_export_upload_cert:
    name: guardian-export-upload-cert
    max_build_duration: 30
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - $HOME/.gradle/wrapper
        - $HOME/.npm
        - $HOME/.cache/yarn
        - $HOME/.cache/metro
        - node_modules
    environment:
      java: 17
      android_signing:
        - guardian-upload
      vars:
        APP_DIR: .
        KEYSTORE_FILE: guardian-upload.jks
        EXPECTED_UPLOAD_CERT_SHA1: "51:7F:61:63:74:A4:3A:BA:DC:07:75:59:CB:D3:97:6E:64:38:F2:C7"
    # Trigger policy:
    # - Avoid wasting versionCode/build slots on every push.
    # - This is manual; dev APK rail is the only auto rail.
    scripts:
      - name: Export guardian upload certificate PEM (for Play upload key reset)
        script: |
          cd "$APP_DIR/android"
          KEYSTORE_PATH=""
          echo "KEYSTORE_FILE=${KEYSTORE_FILE:-}"
          echo "CM_KEYSTORE_PATH=${CM_KEYSTORE_PATH:-}"
          echo "CM_SECURE_FILES_PATH=${CM_SECURE_FILES_PATH:-}"
          echo "CM_BUILD_DIR=${CM_BUILD_DIR:-}"

          if [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}" ]; then
            KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}"
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -d "${CM_KEYSTORE_PATH:-}" ]; then
            if [ -n "${KEYSTORE_FILE:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE" ]; then
              KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE"
            else
              KEYSTORE_PATH="$(find "${CM_KEYSTORE_PATH:-}" -maxdepth 2 -type f -name '*.jks' 2>/dev/null | head -n 1 || true)"
            fi
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_SECURE_FILES_PATH:-}" ] && [ -f "${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE"
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -f "$CM_BUILD_DIR/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="$CM_BUILD_DIR/$KEYSTORE_FILE"
          fi
          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Keystore file not found."
            exit 2
          fi
          if [ -z "${CM_KEYSTORE_PASSWORD:-}" ]; then
            echo "Missing CM_KEYSTORE_PASSWORD."
            exit 2
          fi

          KEYTOOL_LIST="$(keytool -list -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>&1)" || {
            echo "Failed to read keystore with CM_KEYSTORE_PASSWORD."
            echo "$KEYTOOL_LIST" | head -n 20
            exit 8
          }
          KEY_ALIAS="$(echo "$KEYTOOL_LIST" \
            | grep -E 'PrivateKeyEntry|keyEntry' \
            | head -n 1 \
            | awk -F, '{gsub(/^[ \t]+|[ \t]+$/, "", $1); print $1}')"
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null \
              | awk -F': ' '/Alias name:/{print $2; exit}')"
          fi
          if [ -z "$KEY_ALIAS" ]; then
            echo "Failed to detect key alias."
            exit 2
          fi
          echo "KEY_ALIAS=$KEY_ALIAS"

          CERT_INFO="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" -alias "$KEY_ALIAS" 2>&1)" || {
            echo "Failed to read cert details."
            echo "$CERT_INFO" | head -n 40
            exit 8
          }
          echo "$CERT_INFO" | grep -E "SHA1:|SHA256:" || true
          FOUND_SHA1="$(echo "$CERT_INFO" | grep -E "SHA1:" | head -n 1 | sed -E 's/.*SHA1:[[:space:]]*//')"
          echo "FOUND_SHA1=$FOUND_SHA1"
          echo "EXPECTED_SHA1=${EXPECTED_UPLOAD_CERT_SHA1:-}"

          # Export PEM (no secrets inside). This artifact is used to request Play "Upload key reset".
          keytool -exportcert -rfc \
            -alias "$KEY_ALIAS" \
            -keystore "$KEYSTORE_PATH" \
            -storepass "$CM_KEYSTORE_PASSWORD" \
            -file "$CM_BUILD_DIR/guardian_upload_cert.pem"
          ls -la "$CM_BUILD_DIR/guardian_upload_cert.pem" || true
    artifacts:
      - guardian_upload_cert.pem

  android_guardian_internal_apk_dev:
    name: guardian-internal-apk-dev
    max_build_duration: 120
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - $HOME/.gradle/wrapper
        - $HOME/.npm
        - $HOME/.cache/yarn
        - $HOME/.cache/metro
        - node_modules
    environment:
      node: 20.19.4
      java: 17
      android_signing:
        - guardian-upload
      groups:
        - dev
      vars:
        APP_DIR: .
        NODE_ENV: "production"
        VC_BASE: 900000
        # DEV observability rail (always on for internal APK builds)
        EXPO_PUBLIC_DEVTOOLS: "1"
        # Internal test build uses the production package name to minimize Kakao/Play registration friction.
        # (If you need side-by-side install later, we can introduce a dedicated *.dev rail again.)
        DEV_ANDROID_PACKAGE: "kr.slicemind.dongdong.guardian"
        EXPO_PUBLIC_API_URL: "http://api.dongdong.io:3000/api/v1"
        # DEV API와 짝을 맞추기 위해 WebView는 dev-client를 사용 (guardian.dongdong.kr 준비 전)
        EXPO_PUBLIC_WEBVIEW_URL: "http://dev-client.dongdong.io"
        EXPO_PUBLIC_KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        KEYSTORE_FILE: guardian-upload.jks
    triggering:
      events:
        - push
      branch_patterns:
        - pattern: dev
          include: true
      cancel_previous_builds: true
    scripts:
      - name: Assert profile (SEALED)
        script: |
          if [ "${EXPO_PUBLIC_DEVTOOLS:-}" != "1" ]; then
            echo "SEALED: guardian internal APK dev must run with EXPO_PUBLIC_DEVTOOLS=1"
            exit 9
          fi
      - name: Install dependencies (npm ci)
        script: |
          cd "$APP_DIR"
          export npm_config_production=false
          npm ci
      - name: Set Android package + versionCode (DEV internal)
        script: |
          cd "$APP_DIR"
          node -e "
            const fs=require('fs');
            const p='./app.json';
            const j=JSON.parse(fs.readFileSync(p,'utf8'));
            const bn=Number(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||0);
            const base=Number(process.env.VC_BASE||0);
            if (!(Number.isFinite(base) && base>0)) throw new Error('invalid VC_BASE='+base);
            if (!(Number.isFinite(bn) && bn>0)) throw new Error('missing/invalid BUILD_NUMBER='+String(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||''));
            const vc=base + bn;
            j.expo=j.expo||{};
            j.expo.android=j.expo.android||{};
            j.expo.extra=j.expo.extra||{};
            j.expo.extra.devtools=true;
            j.expo.android.package=String(process.env.DEV_ANDROID_PACKAGE||j.expo.android.package);
            j.expo.android.versionCode=vc;
            fs.writeFileSync(p, JSON.stringify(j,null,2)+'\n');
            console.log('[ci] android.package='+j.expo.android.package);
            console.log('[ci] android.versionCode='+j.expo.android.versionCode);
          "
      - name: Expo prebuild (android)
        script: |
          cd "$APP_DIR"
          rm -rf android ios
          npx expo prebuild --platform android --clean
      - name: Android assembleRelease (APK, signed)
        script: |
          cd "$APP_DIR/android"
          # Resolve keystore file path robustly (Codemagic can expose it via different mechanisms).
          KEYSTORE_PATH=""
          echo "KEYSTORE_FILE=${KEYSTORE_FILE:-}"
          echo "CM_KEYSTORE_PATH=${CM_KEYSTORE_PATH:-}"
          echo "CM_SECURE_FILES_PATH=${CM_SECURE_FILES_PATH:-}"
          echo "CM_BUILD_DIR=${CM_BUILD_DIR:-}"

          # 1) Codemagic Android keystore integration (preferred)
          if [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}" ]; then
            KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}"
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -d "${CM_KEYSTORE_PATH:-}" ]; then
            echo "CM_KEYSTORE_PATH is a directory; listing:"
            ls -la "${CM_KEYSTORE_PATH:-}" || true
            if [ -n "${KEYSTORE_FILE:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE" ]; then
              KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE"
            else
              KEYSTORE_PATH="$(find "${CM_KEYSTORE_PATH:-}" -maxdepth 2 -type f -name '*.jks' 2>/dev/null | head -n 1 || true)"
            fi
          fi

          # 2) Secure files
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_SECURE_FILES_PATH:-}" ] && [ -f "${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE"
          fi

          # 3) Build dir (if user uploaded as a generic file)
          if [ -z "$KEYSTORE_PATH" ] && [ -f "$CM_BUILD_DIR/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="$CM_BUILD_DIR/$KEYSTORE_FILE"
          fi

          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Keystore file not found. Ensure Codemagic keystore reference is attached and CM_KEYSTORE_PASSWORD is set."
            exit 2
          fi
          if [ -z "${CM_KEYSTORE_PASSWORD:-}" ]; then
            echo "Missing CM_KEYSTORE_PASSWORD."
            exit 2
          fi
          echo "KEYSTORE_PATH=$KEYSTORE_PATH"
          ls -la "$KEYSTORE_PATH" || true

          # Auto-detect alias to avoid manual mistakes (works when keystore has a single entry).
          KEY_ALIAS="${CM_KEY_ALIAS:-}"
          if [ -z "$KEY_ALIAS" ]; then
            KEYTOOL_LIST="$(keytool -list -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>&1)" || {
              echo "Failed to read keystore with CM_KEYSTORE_PASSWORD (wrong password?)"
              echo "$KEYTOOL_LIST" | head -n 20
              exit 8
            }
            KEY_ALIAS="$(echo "$KEYTOOL_LIST" \
              | grep -E 'PrivateKeyEntry|keyEntry' \
              | head -n 1 \
              | awk -F, '{gsub(/^[ \t]+|[ \t]+$/, "", $1); print $1}')"
          fi
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null \
              | awk -F': ' '/Alias name:/{print $2; exit}')"
          fi
          if [ -z "$KEY_ALIAS" ]; then
            echo "Failed to detect key alias. Set CM_KEY_ALIAS explicitly."
            exit 2
          fi

          KEY_PASS="${CM_KEY_PASSWORD:-$CM_KEYSTORE_PASSWORD}"

          echo "=== SIGNING_INFO (guardian-apk-dev) ==="
          PKG="$(node -p 'require(\"../app.json\").expo.android.package')"
          echo "package=$PKG"
          echo "versionCode=$(node -p 'require(\"../app.json\").expo.android.versionCode')"
          echo "KEY_ALIAS=$KEY_ALIAS"
          CERT_INFO="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" -alias "$KEY_ALIAS" 2>&1)" || {
            echo "Failed to read cert details (wrong password/alias?)"
            echo "$CERT_INFO" | head -n 40
            exit 8
          }
          echo "$CERT_INFO" | grep -E "SHA1:|SHA256:" || true
          if command -v openssl >/dev/null 2>&1; then
            KEY_HASH="$(keytool -exportcert -alias "$KEY_ALIAS" -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null | openssl sha1 -binary | openssl base64 2>/dev/null || true)"
            if [ -n "$KEY_HASH" ]; then
              echo "KAKAO_KEY_HASH=$KEY_HASH"
              # Embed into the JS bundle so the app can display it in DBG (helps unblock Kakao KeyHash registration).
              export EXPO_PUBLIC_KAKAO_KEY_HASH="$KEY_HASH"
              if [ -n "${CM_ENV:-}" ]; then
                echo "EXPO_PUBLIC_KAKAO_KEY_HASH=$KEY_HASH" >> "$CM_ENV"
              fi
              echo "$KEY_HASH" > "$CM_BUILD_DIR/kakao_key_hash.txt"
              SAFE_PKG="${PKG//./_}"
              OUT="$CM_BUILD_DIR/kakao_key_hash_${SAFE_PKG}_${CM_BUILD_NUMBER}.txt"
              {
                echo "package=$PKG"
                echo "build_number=${CM_BUILD_NUMBER:-}"
                echo "key_alias=$KEY_ALIAS"
                echo "kakao_key_hash_base64=$KEY_HASH"
              } > "$OUT"
            fi
          fi

          ./gradlew --no-daemon --build-cache --max-workers=2 :app:assembleRelease \
            -Pandroid.injected.signing.store.file="$KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEYSTORE_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$KEY_PASS"
      - name: Verify + SHA256 (APK)
        script: |
          cd "$APP_DIR/android"
          APK="$(ls -1 app/build/outputs/apk/release/*.apk | head -n 1 || true)"
          if [ -z "$APK" ]; then
            echo "APK not found"
            exit 3
          fi
          echo "APK=$APK"
          if command -v apksigner >/dev/null 2>&1; then
            apksigner verify --print-certs "$APK" || exit 4
          else
            echo "apksigner not found; falling back to jarsigner (may report unsigned for v2/v3-only APKs)"
            jarsigner -verify -verbose -certs "$APK" || exit 4
          fi
          sha256sum "$APK" | tee "$APK.sha256.txt"
    artifacts:
      - kakao_key_hash.txt
      - kakao_key_hash_*.txt
      - android/app/build/outputs/apk/release/*.apk
      - android/app/build/outputs/apk/release/*.sha256.txt
      - android/app/build/reports/**/*
  android_guardian_aab:
    name: guardian-android-aab
    max_build_duration: 120
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - $HOME/.gradle/wrapper
        - $HOME/.npm
        - $HOME/.cache/yarn
        - $HOME/.cache/metro
        - node_modules
    environment:
      node: 20.19.4
      java: 17
      android_signing:
        # IMPORTANT:
        # Guardian Play Console expects a DIFFERENT upload certificate than caregiver.
        # If you sign guardian with the wrong keystore, Play will reject with:
        # "signed with the wrong key ... found SHA1=..., expected SHA1=..."
        - guardian-upload
      groups:
        - google_credentials
      vars:
        APP_DIR: .
        NODE_ENV: "production"
        # SEALED: AAB stamp rail must never enable DEVTOOLS.
        EXPO_PUBLIC_DEVTOOLS: "0"
        # Versioning (prevent Play upload failures due to non-increasing versionCode)
        VC_BASE: 200000
        # Public app config (keep builds deterministic even if Codemagic UI vars are missing)
        EXPO_PUBLIC_API_URL: "http://api.dongdong.io:3000/api/v1"
        # DEV API와 짝을 맞추기 위해 WebView는 dev-client를 사용 (guardian.dongdong.kr 준비 전)
        EXPO_PUBLIC_WEBVIEW_URL: "http://dev-client.dongdong.io"
        EXPO_PUBLIC_KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        # Secrets must be set in Codemagic UI (Environment variables / Groups):
        # - CM_KEYSTORE_PASSWORD
        # - CM_KEY_PASSWORD   (if different from store password)
        # Secure file upload (keystore): upload as `guardian-upload.jks` (recommended).
        KEYSTORE_FILE: guardian-upload.jks
        # Play Console expected upload cert SHA1 for guardian (from Play error message).
        # Used as a guard to fail fast if Codemagic picked the wrong keystore.
        EXPECTED_UPLOAD_CERT_SHA1: "51:7F:61:63:74:A4:3A:BA:DC:07:75:59:CB:D3:97:6E:64:38:F2:C7"
    # Trigger policy:
    # - Avoid wasting versionCode on every push.
    # - AAB rails are manual; dev APK rail is the only auto rail.
    scripts:
      - name: Assert profile (SEALED)
        script: |
          if [ "${EXPO_PUBLIC_DEVTOOLS:-}" != "0" ]; then
            echo "SEALED: guardian AAB must run with EXPO_PUBLIC_DEVTOOLS=0"
            exit 9
          fi
      - name: Install dependencies (npm ci)
        script: |
          cd "$APP_DIR"
          # IMPORTANT:
          # NODE_ENV is set to "production" for Expo config stability, but we still need devDependencies
          # during bundling/prebuild.
          export npm_config_production=false
          npm ci
          node -e "require('./metro.config.js'); console.log('[ci] metro.config.js OK')" || exit 2
      - name: Set Android versionCode (CI monotonic)
        script: |
          cd "$APP_DIR"
          node -e "
            const fs=require('fs');
            const p='./app.json';
            const j=JSON.parse(fs.readFileSync(p,'utf8'));
            const bn=Number(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||0);
            // SEALED: vc+1 rail (vc+1 x2)
            const base=Number(process.env.VC_BASE||0);
            if (!(Number.isFinite(base) && base>0)) throw new Error('invalid VC_BASE='+base);
            if (!(Number.isFinite(bn) && bn>0)) throw new Error('missing/invalid BUILD_NUMBER='+String(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||''));
            const vc=base + bn;
            if (!(Number.isFinite(vc) && vc > 0 && vc < 2100000000)) throw new Error('invalid versionCode='+vc);
            j.expo=j.expo||{};
            j.expo.android=j.expo.android||{};
            j.expo.extra=j.expo.extra||{};
            j.expo.extra.devtools=false;
            j.expo.android.versionCode=vc;
            fs.writeFileSync(p, JSON.stringify(j,null,2)+'\\n');
            console.log('[ci] VC_BASE='+base+' build_number='+bn);
            console.log('[ci] android.versionCode='+vc);
          "
      - name: Expo prebuild (android)
        script: |
          cd "$APP_DIR"
          rm -rf android ios
          npx expo prebuild --platform android --clean
      - name: Android bundleRelease (AAB)
        script: |
          cd "$APP_DIR/android"
          # Resolve keystore file path robustly (Codemagic can expose it via different mechanisms).
          KEYSTORE_PATH=""
          echo "KEYSTORE_FILE=${KEYSTORE_FILE:-}"
          echo "CM_KEYSTORE_PATH=${CM_KEYSTORE_PATH:-}"
          echo "CM_SECURE_FILES_PATH=${CM_SECURE_FILES_PATH:-}"
          echo "CM_BUILD_DIR=${CM_BUILD_DIR:-}"

          # 1) Codemagic Android keystore integration (preferred)
          if [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}" ]; then
            KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}"
          fi
          # Some setups expose CM_KEYSTORE_PATH as a directory. If so, locate the expected KEYSTORE_FILE inside.
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -d "${CM_KEYSTORE_PATH:-}" ]; then
            echo "CM_KEYSTORE_PATH is a directory; listing:"
            ls -la "${CM_KEYSTORE_PATH:-}" || true
            if [ -n "${KEYSTORE_FILE:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE" ]; then
              KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE"
            else
              KEYSTORE_PATH="$(find "${CM_KEYSTORE_PATH:-}" -maxdepth 2 -type f -name '*.jks' 2>/dev/null | head -n 1 || true)"
            fi
          fi

          # 2) Secure files
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_SECURE_FILES_PATH:-}" ] && [ -f "${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE"
          fi

          # 3) Build dir (if user uploaded as a generic file)
          if [ -z "$KEYSTORE_PATH" ] && [ -f "$CM_BUILD_DIR/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="$CM_BUILD_DIR/$KEYSTORE_FILE"
          fi

          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Keystore file not found for guardian."
            echo "Fix: Codemagic > Code signing identities > Android keystores"
            echo " - Add keystore reference name: guardian-upload"
            echo " - Upload file: guardian-upload.jks"
            echo " - Ensure this workflow attaches android_signing: guardian-upload"
            exit 2
          fi
          echo "KEYSTORE_PATH=$KEYSTORE_PATH"
          ls -la "$KEYSTORE_PATH" || true

          if [ -z "${CM_KEYSTORE_PASSWORD:-}" ]; then
            echo "Missing CM_KEYSTORE_PASSWORD. Set it via Codemagic keystore identity or env vars."
            exit 2
          fi

          # Auto-detect alias to avoid manual mistakes (works when keystore has a single entry).
          KEY_ALIAS="${CM_KEY_ALIAS:-}"
          if [ -z "$KEY_ALIAS" ]; then
            KEYTOOL_LIST="$(keytool -list -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>&1)" || {
              echo "Failed to read keystore with CM_KEYSTORE_PASSWORD (wrong password?)"
              echo "$KEYTOOL_LIST" | head -n 20
              exit 8
            }
            KEY_ALIAS="$(echo "$KEYTOOL_LIST" \
              | grep -E 'PrivateKeyEntry|keyEntry' \
              | head -n 1 \
              | awk -F, '{gsub(/^[ \t]+|[ \t]+$/, "", $1); print $1}')"
          fi
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null \
              | awk -F': ' '/Alias name:/{print $2; exit}')"
          fi
          if [ -z "$KEY_ALIAS" ]; then
            echo "Failed to detect key alias. Set CM_KEY_ALIAS explicitly."
            exit 2
          fi

          KEY_PASS="${CM_KEY_PASSWORD:-$CM_KEYSTORE_PASSWORD}"

          echo "=== SIGNING_INFO (guardian) ==="
          PKG="$(node -p 'require(\"../app.json\").expo.android.package')"
          echo "package=$PKG"
          echo "versionCode=$(node -p 'require(\"../app.json\").expo.android.versionCode')"
          echo "KEY_ALIAS=$KEY_ALIAS"
          CERT_INFO="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" -alias "$KEY_ALIAS" 2>&1)" || {
            echo "Failed to read cert details (wrong password/alias?)"
            echo "$CERT_INFO" | head -n 40
            exit 8
          }
          echo "$CERT_INFO" | grep -E "SHA1:|SHA256:" || true
          # Export upload certificate for Play Console "Upload key reset" (no secrets inside).
          # Even if the build fails later (e.g. SHA1 guard), this PEM artifact lets us complete reset without local tools.
          keytool -exportcert -rfc \
            -alias "$KEY_ALIAS" \
            -keystore "$KEYSTORE_PATH" \
            -storepass "$CM_KEYSTORE_PASSWORD" \
            -file "$CM_BUILD_DIR/guardian_upload_cert.pem" 2>/dev/null || true
          # Fail-fast guard: ensure we are signing with the upload certificate Play expects for guardian.
          if [ -n "${EXPECTED_UPLOAD_CERT_SHA1:-}" ]; then
            FOUND_SHA1="$(echo "$CERT_INFO" | grep -E "SHA1:" | head -n 1 | sed -E 's/.*SHA1:[[:space:]]*//')"
            if [ -z "$FOUND_SHA1" ]; then
              echo "FATAL: Could not determine signing cert SHA1 from keytool output."
              exit 9
            fi
            if [ "$FOUND_SHA1" != "$EXPECTED_UPLOAD_CERT_SHA1" ]; then
              echo "FATAL: Wrong signing cert for guardian."
              echo "found_sha1=$FOUND_SHA1"
              echo "expected_sha1=$EXPECTED_UPLOAD_CERT_SHA1"
              exit 9
            fi
          fi
          if command -v openssl >/dev/null 2>&1; then
            KEY_HASH="$(keytool -exportcert -alias "$KEY_ALIAS" -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null | openssl sha1 -binary | openssl base64 2>/dev/null || true)"
            if [ -n "$KEY_HASH" ]; then
              echo "KAKAO_KEY_HASH=$KEY_HASH"
              # Embed into the JS bundle so the app can display it in DBG (helps unblock Kakao KeyHash registration).
              export EXPO_PUBLIC_KAKAO_KEY_HASH="$KEY_HASH"
              if [ -n "${CM_ENV:-}" ]; then
                echo "EXPO_PUBLIC_KAKAO_KEY_HASH=$KEY_HASH" >> "$CM_ENV"
              fi
              # Keep legacy single-line file for backwards-compat.
              echo "$KEY_HASH" > "$CM_BUILD_DIR/kakao_key_hash.txt"
              # Also write a traceable file to avoid confusion across builds/apps.
              SAFE_PKG="${PKG//./_}"
              OUT="$CM_BUILD_DIR/kakao_key_hash_${SAFE_PKG}_${CM_BUILD_NUMBER}.txt"
              {
                echo "package=$PKG"
                echo "build_number=${CM_BUILD_NUMBER:-}"
                echo "key_alias=$KEY_ALIAS"
                echo "kakao_key_hash_base64=$KEY_HASH"
              } > "$OUT"
            fi
          fi

          ./gradlew --no-daemon --build-cache --max-workers=2 :app:bundleRelease \
            -Pandroid.injected.signing.store.file="$KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEYSTORE_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$KEY_PASS"
      - name: Verify + SHA256
        script: |
          cd "$APP_DIR/android"
          AAB="$(ls -1 app/build/outputs/bundle/release/*.aab | head -n 1 || true)"
          if [ -z "$AAB" ]; then
            echo "AAB not found"
            exit 3
          fi
          echo "AAB=$AAB"
          jarsigner -verify -verbose -certs "$AAB" || exit 4
          sha256sum "$AAB" | tee "$AAB.sha256.txt"
      - name: Build universal APK from AAB (bundletool)
        script: |
          cd "$APP_DIR/android"
          AAB="$(ls -1 app/build/outputs/bundle/release/*.aab | head -n 1 || true)"
          if [ -z "$AAB" ]; then
            echo "AAB not found"
            exit 3
          fi

          # Resolve keystore path + alias again (keep this step self-contained).
          KEYSTORE_PATH=""
          if [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}" ]; then KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}"; fi
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_KEYSTORE_PATH:-}" ] && [ -d "${CM_KEYSTORE_PATH:-}" ]; then
            if [ -n "${KEYSTORE_FILE:-}" ] && [ -f "${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE" ]; then
              KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}/$KEYSTORE_FILE"
            else
              KEYSTORE_PATH="$(find "${CM_KEYSTORE_PATH:-}" -maxdepth 2 -type f -name '*.jks' 2>/dev/null | head -n 1 || true)"
            fi
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -n "${CM_SECURE_FILES_PATH:-}" ] && [ -f "${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="${CM_SECURE_FILES_PATH:-}/$KEYSTORE_FILE"
          fi
          if [ -z "$KEYSTORE_PATH" ] && [ -f "$CM_BUILD_DIR/$KEYSTORE_FILE" ]; then
            KEYSTORE_PATH="$CM_BUILD_DIR/$KEYSTORE_FILE"
          fi
          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Keystore file not found for bundletool signing"
            exit 2
          fi
          if [ -z "${CM_KEYSTORE_PASSWORD:-}" ]; then
            echo "Missing CM_KEYSTORE_PASSWORD"
            exit 2
          fi
          KEYTOOL_LIST="$(keytool -list -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>&1)" || exit 8
          KEY_ALIAS_BT="$(echo "$KEYTOOL_LIST" \
            | grep -E 'PrivateKeyEntry|keyEntry' \
            | head -n 1 \
            | awk -F, '{gsub(/^[ \t]+|[ \t]+$/, "", $1); print $1}')"
          if [ -z "$KEY_ALIAS_BT" ]; then
            KEY_ALIAS_BT="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null \
              | awk -F': ' '/Alias name:/{print $2; exit}')"
          fi
          if [ -z "$KEY_ALIAS_BT" ]; then
            echo "Failed to detect key alias"
            exit 2
          fi
          KEY_PASS="${CM_KEY_PASSWORD:-$CM_KEYSTORE_PASSWORD}"

          BUNDLETOOL_VERSION="1.16.0"
          JAR="$CM_BUILD_DIR/bundletool-all.jar"
          if [ ! -f "$JAR" ]; then
            curl -fsSL -o "$JAR" "https://github.com/google/bundletool/releases/download/${BUNDLETOOL_VERSION}/bundletool-all-${BUNDLETOOL_VERSION}.jar"
          fi

          APKS="$CM_BUILD_DIR/app-universal.apks"
          APK="$CM_BUILD_DIR/app-universal.apk"
          java -jar "$JAR" build-apks \
            --bundle="$AAB" \
            --output="$APKS" \
            --mode=universal \
            --ks="$KEYSTORE_PATH" \
            --ks-pass="pass:$CM_KEYSTORE_PASSWORD" \
            --ks-key-alias="$KEY_ALIAS_BT" \
            --key-pass="pass:$KEY_PASS" \
            --overwrite
          unzip -p "$APKS" universal.apk > "$APK"
          ls -la "$APK" "$APKS" || true
          jarsigner -verify -verbose -certs "$APK" || exit 4
          sha256sum "$APK" | tee "$APK.sha256.txt"
    artifacts:
      - kakao_key_hash.txt
      - kakao_key_hash_*.txt
      - guardian_upload_cert.pem
      - app-universal.apk
      - app-universal.apk.sha256.txt
      - app-universal.apks
      - android/app/build/outputs/bundle/release/*.aab
      - android/app/build/outputs/bundle/release/*.sha256.txt
      - android/app/build/outputs/mapping/release/mapping.txt
      - android/app/build/reports/**/*
    publishing:
      google_play:
        credentials: $GOOGLE_PLAY_SERVICE_ACCOUNT_CREDENTIALS
        track: internal
        submit_as_draft: true

  android_guardian_aab_universal_apk_test:
    name: guardian-aab-universal-apk-test
    max_build_duration: 120
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - $HOME/.gradle/wrapper
        - $HOME/.npm
        - $HOME/.cache/yarn
        - $HOME/.cache/metro
        - node_modules
    environment:
      node: 20.19.4
      java: 17
      android_signing:
        - guardian-upload
      groups:
        - dev
      vars:
        APP_DIR: .
        NODE_ENV: "production"
        # Universal APK test rail is a DEV/QA rail (keep DBG enabled)
        EXPO_PUBLIC_DEVTOOLS: "1"
        VC_BASE: 200000
        EXPO_PUBLIC_API_URL: "http://api.dongdong.io:3000/api/v1"
        # DEV API와 짝을 맞추기 위해 WebView는 dev-client를 사용 (guardian.dongdong.kr 준비 전)
        EXPO_PUBLIC_WEBVIEW_URL: "http://dev-client.dongdong.io"
        EXPO_PUBLIC_KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        KAKAO_APP_KEY: "47bc9c4a41a6efc98804915332fbc7e8"
        KEYSTORE_FILE: guardian-upload.jks
    # Trigger policy:
    # - Avoid wasting versionCode on every push.
    # - This workflow is manual; dev APK rail is the only auto rail.
    scripts:
      - name: Assert profile (SEALED)
        script: |
          if [ "${EXPO_PUBLIC_DEVTOOLS:-}" != "1" ]; then
            echo "SEALED: guardian AAB universal APK test must run with EXPO_PUBLIC_DEVTOOLS=1"
            exit 9
          fi
      - name: Install dependencies (npm ci)
        script: |
          cd "$APP_DIR"
          export npm_config_production=false
          npm ci
      - name: Set Android versionCode (CI monotonic)
        script: |
          cd "$APP_DIR"
          node -e "
            const fs=require('fs');
            const p='./app.json';
            const j=JSON.parse(fs.readFileSync(p,'utf8'));
            const bn=Number(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||0);
            const base=Number(process.env.VC_BASE||0);
            if (!(Number.isFinite(base) && base>0)) throw new Error('invalid VC_BASE='+base);
            if (!(Number.isFinite(bn) && bn>0)) throw new Error('missing/invalid BUILD_NUMBER='+String(process.env.CM_BUILD_NUMBER||process.env.BUILD_NUMBER||''));
            const vc=base + bn;
            j.expo=j.expo||{};
            j.expo.android=j.expo.android||{};
            j.expo.android.versionCode=vc;
            fs.writeFileSync(p, JSON.stringify(j,null,2)+'\\n');
            console.log('[ci] android.versionCode='+vc);
          "
      - name: Expo prebuild (android)
        script: |
          cd "$APP_DIR"
          rm -rf android ios
          npx expo prebuild --platform android --clean
      - name: Android bundleRelease (AAB)
        script: |
          cd "$APP_DIR/android"
          ./gradlew --no-daemon --build-cache --max-workers=2 :app:bundleRelease
      - name: Verify + SHA256
        script: |
          cd "$APP_DIR/android"
          AAB="$(ls -1 app/build/outputs/bundle/release/*.aab | head -n 1 || true)"
          if [ -z "$AAB" ]; then
            echo "AAB not found"
            exit 3
          fi
          echo "AAB=$AAB"
          jarsigner -verify -verbose -certs "$AAB" || exit 4
          sha256sum "$AAB" | tee "$AAB.sha256.txt"
      - name: Build universal APK from AAB (bundletool)
        script: |
          cd "$APP_DIR/android"
          AAB="$(ls -1 app/build/outputs/bundle/release/*.aab | head -n 1 || true)"
          if [ -z "$AAB" ]; then
            echo "AAB not found"
            exit 3
          fi
          KEYSTORE_PATH="${CM_KEYSTORE_PATH:-}"
          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Missing CM_KEYSTORE_PATH"
            exit 2
          fi
          if [ -z "${CM_KEYSTORE_PASSWORD:-}" ]; then
            echo "Missing CM_KEYSTORE_PASSWORD"
            exit 2
          fi
          KEYTOOL_LIST="$(keytool -list -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>&1)" || exit 8
          KEY_ALIAS_BT="$(echo "$KEYTOOL_LIST" \
            | grep -E 'PrivateKeyEntry|keyEntry' \
            | head -n 1 \
            | awk -F, '{gsub(/^[ \t]+|[ \t]+$/, "", $1); print $1}')"
          if [ -z "$KEY_ALIAS_BT" ]; then
            KEY_ALIAS_BT="$(keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "$CM_KEYSTORE_PASSWORD" 2>/dev/null \
              | awk -F': ' '/Alias name:/{print $2; exit}')"
          fi
          KEY_PASS="${CM_KEY_PASSWORD:-$CM_KEYSTORE_PASSWORD}"

          BUNDLETOOL_VERSION="1.16.0"
          JAR="$CM_BUILD_DIR/bundletool-all.jar"
          if [ ! -f "$JAR" ]; then
            curl -fsSL -o "$JAR" "https://github.com/google/bundletool/releases/download/${BUNDLETOOL_VERSION}/bundletool-all-${BUNDLETOOL_VERSION}.jar"
          fi
          APKS="$CM_BUILD_DIR/app-universal.apks"
          APK="$CM_BUILD_DIR/app-universal.apk"
          java -jar "$JAR" build-apks \
            --bundle="$AAB" \
            --output="$APKS" \
            --mode=universal \
            --ks="$KEYSTORE_PATH" \
            --ks-pass="pass:$CM_KEYSTORE_PASSWORD" \
            --ks-key-alias="$KEY_ALIAS_BT" \
            --key-pass="pass:$KEY_PASS" \
            --overwrite
          unzip -p "$APKS" universal.apk > "$APK"
          jarsigner -verify -verbose -certs "$APK" || exit 4
          sha256sum "$APK" | tee "$APK.sha256.txt"
    artifacts:
      - app-universal.apk
      - app-universal.apk.sha256.txt
      - app-universal.apks
      - android/app/build/outputs/bundle/release/*.aab
      - android/app/build/outputs/bundle/release/*.sha256.txt
      - android/app/build/reports/**/*

